<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Estuary Flow</title>
    <meta property="og:title" content="Estuary Flow" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://estuary.github.io/slides//featured-slide.jpg" />
    <meta property="og:url" content="https://estuary.github.io/slides/" />
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/league.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./assets/custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Derivations

</script></section><section  data-markdown><script type="text/template">

```SQL
CREATE VIEW sensor_id_date_rollup AS
SELECT
    sensor_id,
    utc_date,
    MIN(degrees) AS degrees_min,
    SUM(1)       AS n_samples,
    FROM sensor_readings
    GROUP BY sensor_id, utc_date;
```

In SQL, you model views as queries.

</script></section><section  data-markdown><script type="text/template">

```yaml
collections:
  - name: sensor/id_date_rollup
    key: [/sensor_id, /utc_date]
    schema: schema.yaml#SensorRollup

    derivation:
      transform:
        fromReadings:
          source: { name: sensor/reading }
```

With Flow, use a [derived collection](https://estuary.readthedocs.io/en/latest/docs/concepts.html#derivations).
* _key_ defines group-by.
* _schema_ defines reductions.

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

```JavaScript
// TypeScript lambda which maps from a `source` reading.
return [{
  sensor_id:   source.sensor_id,
  utc_date:    moment(source.timestamp).format('YYYY-MM-DD'),
  degrees_min: source.degrees,
  n_samples:   1
}];
```

[λ's](https://estuary.readthedocs.io/en/latest/docs/concepts.html#lambdas) map from source collection documents.<br>
Use familiar languages & libraries.

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

```JavaScript
// TypeScript lambda which maps from a `source` reading.
return [{
  sensor_id:   source.sensor_id,
  utc_date:    moment(source.timestamp).format('YYYY-MM-DD'),
  degrees_min: source.degrees,
  n_samples:   1
}];
```

```yaml
$anchor: SensorRollup
properties:
  sensor_id:   { type: integer }
  utc_date:    { format: date }
  degrees_min: { type: number }
  n_samples:   { type: integer }
```

Must match collection schema.<br>
Checked at both build & runtime.

</script></section><section  data-markdown><script type="text/template">

Flow executes via continuous map & combine.<br>
[Materialize](https://estuary.readthedocs.io/en/latest/docs/concepts.html#materializations) into a database to fully reduce the view.

</script></section><section  data-markdown><script type="text/template">

λ's are scale-out, pure functions.<br>
[Registers](https://estuary.readthedocs.io/en/latest/docs/concepts.html#registers) are fast, durable scratch spaces for state:

* Arbitrary JSON documents.
* Declare schema & ``reduce`` annotations.

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Example: find zero-crossings of a running sum.

```YAML
# Register schema
type: number
reduce: { strategy: sum }
```

"Update" lambda runs first:<br>
- Maps a `source` document to register updates.<br>
- Flow reduces these into its value.<br>

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Example: find zero-crossings of a running sum.

```YAML
# Register schema
type: number
reduce: { strategy: sum }
```

```JavaScript
// Update lambda: accumulate into running sum.
return [source.NumberToSum];
```

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Example: find zero-crossings of a running sum.

```JavaScript
// Update lambda: accumulate into running sum.
return [source.NumberToSum];
```

"Publish" lambda runs second:<br>
- Takes: _source_ document, current _register_, and _previous_ register.
- Maps to new documents of the derived collection.<br>

</script></section><section  data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Example: find zero-crossings of a running sum.

```JavaScript
// Update lambda: accumulate into running sum.
return [source.NumberToSum];
```

```JavaScript
// Publish lambda: did our update cross over zero?
if (register > 0 != previous > 0) {
  return [source];
}
return [];
```

</script></section><section  data-markdown><script type="text/template">

Read multiple sources within one derivation.

```yaml [7,8,11,12]
collections:
  - name: sensor/reading_with_calibration
    key: [/sensor_id, /timestamp]

    derivation:
      transform:
        fromReadings:
          source: { name: sensor/readings }
          shuffle: [/sensor_id]

        fromCalibrations:
          source: { name: sensor/calibrations }
          shuffle: [/calibrated_sensor_id]
```

Each has its own "publish" and "update" lambdas.

</script></section><section  data-markdown><script type="text/template">

Registers are shared, keyed by _shuffle_.<br>
Use them to [communicate](https://estuary.readthedocs.io/en/latest/derive-patterns/README.html) between lambdas.

</script></section><section  data-markdown><script type="text/template">

### What's next?

- [How Flow Helps: History](hfh-history.html)

</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"touch":false,"transition":"fade","transitionSpeed":"fast"}, queryOptions);
    </script>

    <script src="./assets/lib/mermaid.min.js"></script>
    <script src="./assets/lib/reveal-mermaid.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
