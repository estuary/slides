---
title: Estuary Flow
separator: <!--s-->
verticalSeparator: <!--v-->
theme: league
scripts: 'lib/mermaid.min.js,lib/reveal-mermaid.js'
---

# Collections

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_1.m4a"></audio>

```yaml
collections:
  - name: shipments
    key: [/id]
```

Collections are a real-time cloud storage lake
that's directly accessible using preferred tools.

Note:
 - Collections are simultaneously a super fast pub/sub topic,
   and a complete description of a data set, stored right in cloud storage.
 - Representation accessible to low-latency EP and MP tools like Snowflake.
 - Fundamentally break down the barrier that today, divides CEP vs MP.

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_2.m4a"></audio>

Documents are [schematized](https://json-schema.org/understanding-json-schema/) JSON.

```yaml
collections:
  - name: shipments
    key: [/id]
```
```yaml
    schema: https://example/shipments.schema.yaml
    projections:
      carrier:
        location: /vendor/name # JSON pointer.
        partition: true
```

<i>Projections</i> relate table columns ⇔ document locations.

Note:
 - Set of JSON documents. Add at any time, update by writing new document with same key.
 - Also schematized. JSON schema against which all documents must validate.
 - Flow integrating against systems which aren't JSON native. Projections are how we relate.

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_3.m4a"></audio>

```yaml
collections:
  - name: shipments
    key: [/id]
```
```yaml
    schema: https://example/shipments.schema.yaml
    projections:
      carrier:
        location: /vendor/name # JSON pointer.
        partition: true
```

Stored as logically partitioned, compressed JSON.

```
shipments/carrier=UPS/utc_date=2020-11-22/{name}.gz
```

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_4.m4a"></audio>

```yaml
collections:
  - name: shipments
    key: [/id]
```
Stored as logically partitioned, compressed JSON.

```
shipments/carrier=UPS/utc_date=2020-11-22/{name}.gz
```

* Query via Snowflake / BigQuery
  * Predicate push-down ➭ <i>fast and cheap</i>.
* Or Spark, Map/Reduce, etc.

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_5.m4a"></audio>

Capture collections by binding from endpoints.

```yaml [2,11|6,12-13]
collections:
  - name: shipments
    key: [/id]

endpoints:
  myKenesisAccount:
    kenesis: "arn:aws:kinesis:us-east-1:my-account-id"

capture:
  fromMyKenesisFirehose:
   - collection: shipments
     endpoint: myKenesisAccount
     stream: Shipments
```

Or from a watched S3 bucket, Database, API, etc...

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_6.m4a"></audio>

Materialize collections by binding to endpoints.

```yaml [2,11|6,12-13]
collections:
  - name: shipments
    key: [/id]

endpoints:
  myDatabase:
    postgresql: "https://CLUSTER_ID.LOCAL_HOST_IP.ip.es.io:9243"

materialize:
  shipmentsToPostgres:
   - collection: shipments
     endpoint: myDatabase
     table: shipments_by_id
```

Materialize into SQL, NoSQL, Pub/Sub, & APIs.

<!--s-->
<!-- .slide: data-auto-animate -->
<audio controls src="media/collections_7.m4a"></audio>

Schema is _projected_ into the target system.

```yaml []
collections:
  - name: shipments
    key: [/id]
    schema: https://example/shipments.schema.yaml
```
```SQL []
-- Generated by Flow from `shipments`.
CREATE TABLE shipments (
  id       BIGINT PRIMARY KEY NOT NULL,
  carrier  TEXT NOT NULL,
  address  TEXT
);
```

Primary key is always the collection key.

<!--s-->

### What's next?

- [Reductions](reductions.html)
- [Derivations](derivations.html)
- [How Flow Helps: History](hfh-history.html)

